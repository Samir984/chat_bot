from typing import List, Optional
from uuid import UUID
from chat_bot.env import ENV
from langchain_core.messages import AIMessage
from django.http import HttpRequest
from django.shortcuts import get_object_or_404
from django.db import transaction

from ninja import Router, UploadedFile, File, Form
from user.authentication import CookieJWTAuth
from chat.models import Conversation, RAGCollection, RAGDocument
from chat.schema import CreateRAGCollectionSchema, RAGCollectionListSchema
from chat.tasks import start_indexing_documents
from chat.llm_service import llm_model
from chat.schema import (
    PublicChatRequestSchema,
    ChatResponseSchema,
    ChatRequestSchema,
    GenericSchema,
    SelectedConversationSchema,
    ConversationListResponseSchema,
    StartIndexingResponseSchema,
    IndexingStatusResponseSchema,
)
from chat.utils import (
    build_messages_from_history,
    validate_documents,
    build_rag_system_message,
)
from chat.qdrant_client import (
    get_vector_store,
    delete_vector_collection,
    delete_document_vectors,
)
from langchain_core.messages import SystemMessage

cookie_auth = CookieJWTAuth()
chat = Router()
conversation = Router()
rag_collection = Router()


# For unauthenticated users
@chat.post("/public/", response={200: ChatResponseSchema})
def public_send_message(request: HttpRequest, data: PublicChatRequestSchema):
    messages = build_messages_from_history(data.history, data.prompt)
    message = llm_model.invoke(messages, max_retries=0)
    return ChatResponseSchema(content=message.content)


# For authenticated users
@chat.post("/", response={200: ChatResponseSchema, 400: GenericSchema}, auth=cookie_auth)
def send_message(request: HttpRequest, data: ChatRequestSchema):
    user = request.auth
    conversation = None

    if data.conversation_id:
        conversation = Conversation.objects.get(id=data.conversation_id, user=user)
    try:
        messages = []
        if data.collection_name:
            rag_collection = RAGCollection.objects.filter(
                rag_collection_name=data.collection_name, user=user
            ).first()

            if not rag_collection:
                return 400, GenericSchema(
                    detail=f"Collection with name '{data.collection_name}' not found or you don't have access to it."
                )

            qdrant_collection_name = rag_collection.qdrant_collection_name
            if not qdrant_collection_name:
                return 400, GenericSchema(
                    detail=f"Collection '{data.collection_name}' does not have a Qdrant collection name configured."
                )
            vector_store = get_vector_store(qdrant_collection_name)
            if not vector_store:
                return 400, GenericSchema(
                    detail=f"Qdrant collection '{data.collection_name}' not found"
                )
            results = vector_store.similarity_search(data.prompt, k=4)

            # Format results for the system message - limit context length to avoid token limits
            context_chunks = [result.page_content for result in results]
            context_text = "\n\n---\n\n".join(context_chunks)
            # Build system message with context
            system_content = build_rag_system_message(context_text)
            messages.insert(0, SystemMessage(content=system_content))

        existing_history = conversation.history if conversation else []
        history_messages = build_messages_from_history(existing_history, data.prompt)
        messages.extend(history_messages)
  
        # temp changes to save ai user during development
   
        if ENV.DEBUG is True:
            message_content = "This is a test message generated by the system no ai for development purpose"
            message = AIMessage(content=message_content)

        else:
           message = llm_model.invoke(messages, max_retries=0)

        if message.content:
            updated_history = [
                *existing_history,
                {"role": "user", "content": data.prompt},
                {"role": "assistant", "content": message.content},
            ]

            if not data.conversation_id:
                conversation = Conversation.objects.create(
                    user=user,
                    conversation_title=data.prompt[:50],
                    history=updated_history,
                )
            else:
                conversation.history = updated_history
                conversation.save()
    
        
            return 200, ChatResponseSchema(
                conversation_id=conversation.id, content=message.content
            )

    except Exception as e:
        print("Error in send_message:", str(e))
        return 400, GenericSchema(detail=str(e))


@conversation.get(
    "/list/", response={200: list[ConversationListResponseSchema]}, auth=cookie_auth
)
def get_user_conversations_list(request: HttpRequest):
    conversations = Conversation.objects.filter(user=request.auth).values(
        "id", "conversation_title"
    )
    print(conversations)
    return [
        ConversationListResponseSchema(
            conversation_id=conversation["id"],
            conversation_title=conversation["conversation_title"],
        )
        for conversation in conversations
    ]


@conversation.get(
    "/{conversation_id}/", response={200: SelectedConversationSchema}, auth=cookie_auth
)
def get_conversation(request: HttpRequest, conversation_id: UUID):
    conversation = get_object_or_404(
        Conversation, id=conversation_id, user=request.auth
    )
    return SelectedConversationSchema(
        conversation_id=conversation.id, history=conversation.history
    )


@conversation.delete(
    "/{conversation_id}/", response={200: GenericSchema}, auth=cookie_auth
)
def delete_conversation(request: HttpRequest, conversation_id: UUID):
    conversation = get_object_or_404(
        Conversation, id=conversation_id, user=request.auth
    )
    conversation.delete()
    return GenericSchema(detail="Conversation deleted successfully")


@rag_collection.get(
    "/list/", response={200: list[RAGCollectionListSchema]}, auth=cookie_auth
)
def list_user_rag_collections(request: HttpRequest):
    user = request.auth
    rag_collections = RAGCollection.objects.filter(user=user).prefetch_related(
        "documents"
    )
    return [
        RAGCollectionListSchema(
            id=rag_collection.id,
            rag_collection_name=rag_collection.rag_collection_name,
            documents=rag_collection.documents.all(),
            qdrant_collection_name=rag_collection.qdrant_collection_name,
        )
        for rag_collection in rag_collections
    ]


@rag_collection.post(
    "/", response={200: GenericSchema, 400: GenericSchema}, auth=cookie_auth
)
def create_rag_collection(
    request: HttpRequest,
    rag_collection_name: str = Form(...),
    files: Optional[List[UploadedFile]] = File(None),
):
    """
    Create a new RAG collection with optional PDF uploads.
    """
    try:
        user = request.auth
        upload_files = files or []

        # Validate documents before creating collection (allow empty uploads for just creating the collection)
        is_valid, error_message = validate_documents(upload_files, allow_empty=True)
        if not is_valid:
            return 400, GenericSchema(detail=error_message)

        exits_rag_collection = RAGCollection.objects.filter(
            rag_collection_name=rag_collection_name, user=user
        ).exists()
        if exits_rag_collection:
            return 400, GenericSchema(
                detail="RAG collection already exists. Please use a different name."
            )

        with transaction.atomic():
            rag_collection = RAGCollection.objects.create(
                rag_collection_name=rag_collection_name, user=user
            )
            for file in upload_files:
                RAGDocument.objects.create(
                    rag_collection=rag_collection,
                    original_document_name=file.name,
                    document_path=file,
                    is_indexed=False,
                )

        return 200, GenericSchema(detail="RAG collection created successfully")

    except Exception as e:
        return 400, GenericSchema(detail=f"Error creating RAG collection: {str(e)}")


@rag_collection.patch(
    "/{rag_collection_id}/",
    response={200: GenericSchema, 400: GenericSchema},
    auth=cookie_auth,
)
def update_rag_collection(
    request: HttpRequest,
    rag_collection_id: int,
    rag_collection_name: Optional[str] = Form(None),
    files: Optional[List[UploadedFile]] = File(None),
):
    rag_collection = get_object_or_404(
        RAGCollection, id=rag_collection_id, user=request.auth
    )
    if rag_collection_name:
        rag_collection.rag_collection_name = rag_collection_name
        rag_collection.save()
    is_valid, error_message = validate_documents(files or [], allow_empty=True)
    if not is_valid:
        return 400, GenericSchema(detail=error_message)
    with transaction.atomic():
        for file in files or []:
            RAGDocument.objects.create(
                rag_collection=rag_collection,
                original_document_name=file.name,
                document_path=file,
                is_indexed=False,
            )
    return 200, GenericSchema(detail="RAG collection updated successfully")


@rag_collection.delete(
    "/{rag_collection_id}/",
    response={200: GenericSchema},
    auth=cookie_auth,
)
def delete_rag_collection(request: HttpRequest, rag_collection_id: int):
    rag_collection = get_object_or_404(
        RAGCollection, id=rag_collection_id, user=request.auth
    )

    qdrant_collection_name = rag_collection.qdrant_collection_name
    documents = list(rag_collection.documents.all())


    for document in documents:
        if document.document_path:
            document.document_path.delete(save=False)
        document.delete()

   
    if qdrant_collection_name:
        delete_vector_collection(qdrant_collection_name)

    rag_collection.delete()

    return 200, GenericSchema(detail="RAG collection and documents deleted successfully")


@rag_collection.delete(
    "/{rag_collection_id}/document/{document_id}/",
    response={200: GenericSchema},
    auth=cookie_auth,
)
def delete_rag_collection_document(request: HttpRequest, rag_collection_id: int, document_id: int):
    try:
        rag_collection = get_object_or_404(
            RAGCollection, id=rag_collection_id, user=request.auth
        )
        document = get_object_or_404(
            RAGDocument, id=document_id, rag_collection=rag_collection
        )

        qdrant_collection_name = rag_collection.qdrant_collection_name
        if qdrant_collection_name:
            delete_document_vectors(qdrant_collection_name, document.id)

        if document.document_path:
            document.document_path.delete(save=False)

        document.delete()
        return 200, GenericSchema(detail="RAG collection document deleted successfully")
    except Exception as e:
        return 400, GenericSchema(detail=f"Error deleting RAG collection document: {str(e)}")


@rag_collection.get(
    "/start-indexing/{rag_collection_id}/",
    response={200: GenericSchema, 202: StartIndexingResponseSchema},
    auth=cookie_auth,
)
def start_indexing(request: HttpRequest, rag_collection_id: int):
    rag_collection = get_object_or_404(
        RAGCollection, id=rag_collection_id, user=request.auth
    )
    is_all_documents_indexed = (
        rag_collection.documents.all().filter(is_indexed=False).count() == 0
    )

    if is_all_documents_indexed:
        return 200, GenericSchema(detail="All documents are already indexed")

    # start indexing unindexed documents in background
    async_result = start_indexing_documents.delay(
        rag_collection_id, rag_collection.qdrant_collection_name
    )

    return 202, StartIndexingResponseSchema(task_id=async_result.id)




@rag_collection.get(
    "/indexing-status/{task_id}/",
    response={200: IndexingStatusResponseSchema, 200: GenericSchema},
    auth=cookie_auth,
)
def get_indexing_status(request: HttpRequest, task_id: str):
    async_result = start_indexing_documents.AsyncResult(task_id)
    if not async_result.result:
        return 200, GenericSchema(detail="No Indexing Task Found")
    return 200, IndexingStatusResponseSchema(
        status=async_result.status,
        progress=async_result.meta.get("progress"),
        message=async_result.meta.get("message"),
    )

